<html>
<head>
  <title>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="670"/>
<h1>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组</h1>

<div>
<span><div>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</div><div>注意：答案中不可以包含重复的三元组。</div><div>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</div><div><br/></div><div>满足要求的三元组集合为：</div><div>[</div><div>  [-1, 0, 1],</div><div>  [-1, -1, 2]</div><div>]</div><div><br/></div><div><br/></div><div>在 2sum问题 的基础上来解决3sum问题，3sum问题的目标是target。</div><div>每次从数组中选出一个数k。从剩下的数中求目标等于target-k的2sum问题。这里须要注意的是有个小的trick：当我们从数组中选出第i数时，我们仅仅须要求数值中从第i+1个到最后一个范围内字数组的2sum问题。</div><div><br/></div><div><br/></div><div>class Solution {</div><div>    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {</div><div>        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();</div><div><br/></div><div>        if (nums != null &amp;&amp; nums.length &gt; 2) {</div><div>            // 先对数组进行排序</div><div>            Arrays.sort(nums);</div><div>            // i表示如果取第i个数作为结果</div><div>            for (int i = 0; i &lt; nums.length - 2; ) {</div><div>                // 第二个数可能的起始位置</div><div>                int j = i + 1;</div><div>                // 第三个数可能是结束位置</div><div>                int k = nums.length - 1;</div><div><br/></div><div>                while (j &lt; k) {</div><div>                    // 如果找到满足条件的解</div><div>                    if (nums[j] + nums[k] == -nums[i]) {</div><div>                        // 将结果加入到结果含集中</div><div>                        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(3);</div><div>                        list.add(nums[i]);</div><div>                        list.add(nums[j]);</div><div>                        list.add(nums[k]);</div><div>                        result.add(list);</div><div><br/></div><div>                        // 移动到下一个位置。找下一组解</div><div>                        k--;</div><div>                        j++;</div><div><br/></div><div>                        // 从左向右找第一个与之前处理的数不同的数的下标</div><div>                        while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) {</div><div>                            j++;</div><div>                        }</div><div>                        // 从右向左找第一个与之前处理的数不同的数的下标</div><div>                        while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) {</div><div>                            k--;</div><div>                        }</div><div>                    }</div><div>                    // 和大于0</div><div>                    else if (nums[j] + nums[k] &gt; -nums[i]) {</div><div>                        k--;</div><div>                        // 从右向左找第一个与之前处理的数不同的数的下标</div><div>                        while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) {</div><div>                            k--;</div><div>                        }</div><div>                    }</div><div>                    // 和小于0</div><div>                    else {</div><div>                        j++;</div><div>                        // 从左向右找第一个与之前处理的数不同的数的下标</div><div>                        while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) {</div><div>                            j++;</div><div>                        }</div><div>                    }</div><div>                }</div><div><br/></div><div>                // 指向下一个要处理的数</div><div>                i++;</div><div>                // 从左向右找第一个与之前处理的数不同的数的下标</div><div>                while (i &lt; nums.length - 2 &amp;&amp; nums[i] == nums[i - 1]) {</div><div>                    i++;</div><div>                }</div><div>            }</div><div>        }</div><div><br/></div><div>        return result;</div><div><br/></div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>速率最快</div><div>import java.util.ArrayList;</div><div>import java.util.Arrays;</div><div>import java.util.Collections;</div><div>import java.util.List;</div><div>class Solution {</div><div>    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {</div><div>      if (nums.length &lt; 3)</div><div>        return Collections.emptyList();</div><div>      List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</div><div>      int minValue = Integer.MAX_VALUE;</div><div>      int maxValue = Integer.MIN_VALUE;</div><div>      int negSize = 0;</div><div>      int posSize = 0;</div><div>      int zeroSize = 0;</div><div>      for (int v : nums) {</div><div>        if (v &lt; minValue)</div><div>          minValue = v;</div><div>        if (v &gt; maxValue)</div><div>          maxValue = v;</div><div>        if (v &gt; 0)</div><div>          posSize++;</div><div>        else if (v &lt; 0)</div><div>          negSize++;</div><div>        else</div><div>          zeroSize++;</div><div>      }</div><div>      if (zeroSize &gt;= 3)</div><div>        res.add(Arrays.asList(0, 0, 0));</div><div>      if (negSize == 0 || posSize == 0)</div><div>        return res;</div><div>      if (minValue * 2 + maxValue &gt; 0)</div><div>        maxValue = -minValue * 2;</div><div>      else if (maxValue * 2 + minValue &lt; 0)</div><div>        minValue = -maxValue * 2;</div><div><br/></div><div>      int[] map = new int[maxValue - minValue + 1];</div><div>      int[] negs = new int[negSize];</div><div>      int[] poses = new int[posSize];</div><div>      negSize = 0;</div><div>      posSize = 0;</div><div>      for (int v : nums) {</div><div>        if (v &gt;= minValue &amp;&amp; v &lt;= maxValue) {</div><div>          if (map[v - minValue]++ == 0) {</div><div>            if (v &gt; 0)</div><div>              poses[posSize++] = v;</div><div>            else if (v &lt; 0)</div><div>              negs[negSize++] = v;</div><div>          }</div><div>        }</div><div>      }</div><div>      Arrays.sort(poses, 0, posSize);</div><div>      Arrays.sort(negs, 0, negSize);</div><div>      int basej = 0;</div><div>      for (int i = negSize - 1; i &gt;= 0; i--) {</div><div>        int nv = negs[i];</div><div>        int minp = (-nv) &gt;&gt;&gt; 1;</div><div>        while (basej &lt; posSize &amp;&amp; poses[basej] &lt; minp)</div><div>          basej++;</div><div>        for (int j = basej; j &lt; posSize; j++) {</div><div>          int pv = poses[j];</div><div>          int cv = 0 - nv - pv;</div><div>          if (cv &gt;= nv &amp;&amp; cv &lt;= pv) {</div><div>            if (cv == nv) {</div><div>              if (map[nv - minValue] &gt; 1)</div><div>                res.add(Arrays.asList(nv, nv, pv));</div><div>            } else if (cv == pv) {</div><div>              if (map[pv - minValue] &gt; 1)</div><div>                res.add(Arrays.asList(nv, pv, pv));</div><div>            } else {</div><div>              if (map[cv - minValue] &gt; 0)</div><div>                res.add(Arrays.asList(nv, cv, pv));</div><div>            }</div><div>          } else if (cv &lt; nv)</div><div>            break;</div><div>        }</div><div>      }</div><div>      return res;</div><div>    }</div><div>}</div></span>
</div></body></html> 