<html>
<head>
  <title>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="662"/>
<h1>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</h1>

<div>
<span><div>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</div><div>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</div><div>你可以假设 nums1 和 nums2 不同时为空。</div><div>示例 1:</div><div>nums1 = [1, 3]</div><div>nums2 = [2]</div><div><br/></div><div>中位数是 2.0</div><div>示例 2:</div><div>nums1 = [1, 2]</div><div>nums2 = [3, 4]</div><div><br/></div><div>中位数是 (2 + 3)/2 = 2.5</div><div><br/></div><div><br/></div><div><br/></div><div>在不考虑时间复杂度的情况下，合并数组后找出中位值</div><div>class Solution {</div><div>    public double findMedianSortedArrays(int[] nums1, int[] nums2) {</div><div>        int len1=nums1.length;</div><div>        int len2=nums2.length;</div><div>        if(len1!=0 &amp;&amp; len2==0){</div><div>            double res=0.0;</div><div>            if(len1%2==0){</div><div>                res=(double)(nums1[len1/2]+nums1[len1/2-1])/2;</div><div>            }else{</div><div>                res=nums1[len1/2];</div><div>            }</div><div>            return res;</div><div>        }</div><div>        if(len2!=0 &amp;&amp; len1==0){</div><div>            double res=0.0;</div><div>            if(len2%2==0){</div><div>                res=(double)(nums2[len2/2]+nums2[len2/2-1])/2;</div><div>            }else{</div><div>                res=nums2[len2/2];</div><div>            }</div><div>            return res;</div><div>        }</div><div>        int i=0,j=0;</div><div>        int count=0;</div><div>        int[] res=new int[len1+len2];</div><div>        int mid=(len1+len2-1)/2;</div><div>        if(len1!=0 &amp;&amp; len2!=0){</div><div>            while(i&lt;len1 &amp;&amp; j&lt;len2){</div><div>                if(nums1[i]&lt;=nums2[j]){</div><div>                    res[count]=nums1[i];</div><div>                    i++;</div><div>                }else{</div><div>                    res[count]=nums2[j];</div><div>                    j++;</div><div>                }</div><div>                count++;</div><div>            }</div><div>            while(i&lt;len1 &amp;&amp; count&lt;=mid+1){//</div><div>                res[count++]=nums1[i];</div><div>                i++;</div><div>            }</div><div>            while(j&lt;len2 &amp;&amp; count&lt;=mid+1){//</div><div>                res[count++]=nums2[j];</div><div>                j++;</div><div>            }</div><div>        }</div><div>        if((len1+len2)%2==0){</div><div>            return (double)(res[mid]+res[mid+1])/2;</div><div>        }else{</div><div>            return (double)res[mid];</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div>要求算法的时间复杂度为 O(log (m+n)) 。</div><div>如果数组a的中位数小于数组b的中位数，那么整体的中位数只可能出现在a的右区间加上b的左区间之中；</div><div>如果数组a的中位数大于等于数组b的中位数，那么整体的中位数只可能出现在a的左区间加上b的右区间之中。</div><div>关键就是利用分治的思想逐渐缩小a的区间和b的区间来找到中位数。</div><div><br/></div><div>class Solution {</div><div>    public double findMedianSortedArrays(int[] nums1, int[] nums2) {</div><div>        int m = nums1.length;</div><div>        int n = nums2.length;</div><div>        if (nums1==null) {</div><div>            if (n%2 != 0)</div><div>                return 1.0*nums2[n/2];</div><div>            return (nums2[n/2]+nums2[n/2-1])/2.0;</div><div>        }</div><div>        if (nums2==null) {</div><div>            if (m%2 != 0)</div><div>                return 1.0*nums1[m/2];</div><div>            return (nums1[m/2]+nums1[m/2-1])/2.0;</div><div>        }</div><div><br/></div><div>        int total = (m+n+1)/2;</div><div>        int total2 = (m+n+2)/2;</div><div><br/></div><div>        return (find_kth(nums1,0,nums2,0,total)+find_kth(nums1,0,nums2,0,total2))/2.0;</div><div><br/></div><div>    }</div><div>    double find_kth(int[] a, int a_begin, int[] b, int b_begin, int k) {</div><div>        if (a_begin &gt; a.length-1)</div><div>            return b[b_begin+k-1];</div><div>        if (b_begin &gt; b.length-1)</div><div>            return a[a_begin+k-1];</div><div>        if (k == 1)</div><div>            return Math.min(a[a_begin],b[b_begin]);</div><div><br/></div><div>        int mid_a = Integer.MAX_VALUE;</div><div>        int mid_b = Integer.MAX_VALUE;</div><div>        if (a_begin+k/2-1 &lt; a.length)</div><div>            mid_a = a[a_begin+k/2-1];</div><div>        if (b_begin+k/2-1 &lt; b.length)</div><div>            mid_b = b[b_begin+k/2-1];</div><div><br/></div><div>        if (mid_a &lt; mid_b)</div><div>            return find_kth(a,a_begin+k/2,b,b_begin,k-k/2);</div><div>        return find_kth(a,a_begin,b,b_begin+k/2,k-k/2);</div><div>    }</div><div><br/></div><div>}</div><div><br/></div><div><br/></div><div>利用二分查找的思想每次剔除大范围元素提高搜索效率。因为查找中位数实质上是查找第k个元素。</div><div>对于数组A前p个元素A[0]、A[1]、A[2]、……A[p-1]，有p-1个元素不大于A[p-1]，同样数组B前k-p个元素B[0]、B[1]、B[2]、……B[k-p-1]，有k-p-1个元素不大于B[k-p-1]。比较A[p-1]和B[k-p-1]存在三种情况：</div><div>1、若A[p-1]=B[k-p-1]，那么共有p-1+(k-p-1)+1个元素不大于A[p-1]，也就是说A[p-1]即是第k小的数。  </div><div>2、若A[p-1]&lt; B[k-p-1]，那么第k小的数不可能在区间A[0,p)之内。我们可以用反证法证明，若第k小的数在A[0,p)中设为A[i]，那么A[i]前面只有i个数不比它大，不妨设A[p-1]是第k小的数即i=p-1，也就是说最多只有p-1个数不比它大，而B[k-p-1]大于A[p-1]，所以B[k-p-1]之后的所有数都大于A[p-1]，这样即使B[p-k-1]之前的所有数都不比A[p-1]大，B中也只能找到k-p-1个数不比A[p-1]大。那么A和B中最多只有p-1+(k-p-1)=k-2个数不大于A[p-1]，从而A[p-1]不是第k小的数。  </div><div>这里要注意推论第k小的数不在某区间的前提是同一数组中元素的相对位置不变，只有之前的数不比某个数大，之后的数不论是否相等都比它“大”。如122234中第2个2只有两个数1、2不比它大，第3个2不算在内。否则，第k小的数可能出现在任何位置，如A={1,1,1,1,1}，B={1,1,1,1,1}。 但是即使认为第k小的数可以出现在任何位置，上面的推论也没有错，因为除了区间A[0,p)之外必定会出现一个第k小，而我们只需要找到一个就可以了，因此舍弃掉区间A[0,p)是可行的。如A={0,1,1}和B={0,1,2,4,5,6}找第5小的数字，舍弃掉A(0,1)仍然可以找到解1。  </div><div>同样我们可以通过反证法证明，B[k-p-1]之后的数不可能是第k小的数，因为它至少是B[k-p]，前面有k-p个数不比B[k-p]大，再加上A[0,p)有p个数不比B[k-p]大，所以至少有k-p+p=k个数不比B[k-p-1]大，也就是说B[k-p]至少是第k+1小的数而不可能是第k小的数。 舍弃区间之后问题就变成寻找第k-p小的数了。  </div><div>3、同理若A[p-1]&gt;B[k-p-1]可以舍弃掉B[0,p)区间和A[p-1]之后的区间。</div><div>每次比较 nums1[k/2 - 1] 和 nums2[k/2 - 1] 的大小，删除较小的数列的前k/2个数字，直到k的值为1时，这时，只要比较nums1和nums2的第一个数字即可</div></span>
</div></body></html> 